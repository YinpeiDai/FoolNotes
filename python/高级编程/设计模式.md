- [单例模式](#单例模式)
- [原型模式](#原型模式)
- [工厂模式](#工厂模式)
- [建造者模式](#建造者模式)
- [适配器模式](#适配器模式)
- [装饰器模式](#装饰器模式)

### 单例模式
```python
class Singleton(object):
    def __new__(cls, *args, **kwargs):
        if not hasattr(cls, '_instance'):
            cls._instance = super(Singleton, cls).__new__(cls, *args, **kwargs)
        return cls._instance
```
或者
```python
def singleton(cls):
    instances = {}
    def wrapper(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]
    return wrapper

@singleton
class AnyClass(object):
    pass
```

### 原型模式
用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。  
原型模式本质就是克隆对象，所以在对象初始化操作比较复杂的情况下，很实用，能大大降低耗时，提高性能，因为“不用重新初始化对象，而是动态地获得对象运行时的状态”。
```python
import copy
class Prototype:
    def __init__(self):
        self.objects = dict()

    def register(self, identifier, obj):
        self.objects[identifier] = obj

    def unregister(self, identifier):
        del self.objects[identifier]

    def clone(self, identifier, **attr):
        found = self.objects.get(identifier)
        if not found:
            raise ValueError('Incorrect object identifier: {}'.format(identifier))
        obj = copy.deepcopy(found)
        obj.__dict__.update(attr)
        return obj
```

### 工厂模式
工厂模式是用来创建对象的
```python
class Person:
    def __init__(self):
        self.name = None
        self.gender = None
    def getName(self):
        return self.name
    def getGender(self):
        return self.gender

class Male(Person):
    def __init__(self, name):
        super().__init__()
        print("Hello Mr." + name)

class Female(Person):
    def __init__(self, name):
        super().__init__()
        print("Hello Miss." + name)

class Factory:
    def getPerson(self, name, gender):
        if gender in ['M','m','Male','male']:
            return Male(name)
        elif gender in ['F','f','Female','female']:
            return Female(name)
        else:
            return None

if __name__ == '__main__':
    factory = Factory()
    person = factory.getPerson("Chetan", "M")
```

### 建造者模式
升级版的工厂模式，用于复杂对象的构建，对类的方法也进行组合构建

### 适配器模式
适配器模式(Adapter Pattern):将一个类的接口转换成为客户希望的另外一个接口.Adapter Pattern使得原本由于接口不兼容而不能一起工作的那些类可以一起工作.  
应用场景:系统数据和行为都正确,但接口不符合时,目的是使控制范围之外的一个原有对象与某个接口匹配,适配器模式主要应用于希望复用一些现存的类,但接口又与复用环境不一致的情况

### 装饰器模式
在不改变原函数或类的前提下，在代码运行期间动态增加功能
